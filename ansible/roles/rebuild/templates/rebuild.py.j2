#!/opt/slurm-tools/bin/python3
# -*- coding: utf-8 -*-

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import logging.handlers
import os
from os import path
import sys
import socket
import subprocess

import openstack
import pbr.version

__version__ = pbr.version.VersionInfo("slurm-openstack-tools").version_string()

MAX_REASON_LENGTH = 1000

# configure logging to syslog - by default only "info"
# and above categories appear
logger = logging.getLogger("syslogger")
logger.setLevel(logging.DEBUG)
handler = logging.handlers.SysLogHandler("/dev/log")
handler.setFormatter(logging.Formatter(sys.argv[0] + ': %(message)s'))
logger.addHandler(handler)

def get_statesavelocation():
    """ Return the path for Slurm's StateSaveLocation """
    scontrol = subprocess.run(['scontrol', 'show', 'config'], stdout=subprocess.PIPE, universal_newlines=True)
    for line in scontrol.stdout.splitlines():
        if line.startswith('StateSaveLocation'): # StateSaveLocation       = /var/spool/slurm
            return line.split()[-1]

def get_openstack_server_id(node):

    statedir = get_statesavelocation()
    instance_file = os.path.join(statedir, node)
    try:
        with open(instance_file) as f:
            instance_id = f.readline().strip()
            return instance_id
    except FileNotFoundError:
        logger.error(f"no instance file found in {statedir} for node {node}")
        return None

def get_sinfo_path():
    # TODO(johngarbutt): get this from environment or config file?
    sinfo_alt_path = "/usr/local/software/slurm/current/bin/sinfo"
    if path.exists(sinfo_alt_path):
        return sinfo_alt_path
    return "sinfo"


def get_reboot_reason(node):
    sinfo_path = get_sinfo_path()
    # see why we're being rebooted:
    sinfo = subprocess.run(
        [
            sinfo_path,
            "--noheader",
            "--nodes=%s" % node,
            "-O",
            "Reason:%i" % MAX_REASON_LENGTH,
        ],
        stdout=subprocess.PIPE,
        universal_newlines=True,
    )
    return sinfo.stdout.strip()


def get_image_from_reason(reason):
    tokens = reason.split()
    image = None
    if len(tokens) > 1:
        image_tokens = tokens[1].split(":")
        if len(image_tokens) == 2 and image_tokens[0] == "image":
            if image_tokens[1]:
                image = image_tokens[1]
                logger.info(f"user requested image: {image}")
    return image


def rebuild_openstack_server(server_id, reason):
    # Validate server_id
    conn = openstack.connection.from_config()
    try:
        server = conn.get_server(server_id)
    except openstack.exceptions.ResourceNotFound:
        logger.error(f"server id {server_id} is not valid")
        return None

    image_name_or_uuid = get_image_from_reason(reason)
    if not image_name_or_uuid:
        image_name_or_uuid = server.image.id
        logger.info(f"couldn't parse image from reason '{reason}', falling back to existing image: {image_name_or_uuid}")
    
    image = conn.image.find_image(image_name_or_uuid) # doesn't throw exception
    if image is None:
        logger.error(f"image {image_name_or_uuid} either not found or not unique")
        return None
    
    # Note that OpenStack will power down the server as part of the rebuild
    logger.info(f"rebuilding server {server_id} with image {image.id}")
    conn.rebuild_server(server_id, image.id)

def reboot_openstack_server(server_id):
    conn = openstack.connection.from_config()
    server = conn.get_server(server_id)
    logger.info(f"rebooting server %{server_id} with image %{image_uuid}")
    conn.reboot_server(server_id, 'SOFT')

def expand_nodes(hostlist_expr):
    scontrol = subprocess.run(['scontrol', 'show', 'hostnames', hostlist_expr], stdout=subprocess.PIPE, universal_newlines=True)
    return scontrol.stdout.strip().split('\n')

def rebuild_or_reboot():
    """ Rebuild or reboot an OpenStack node from the controller. """

    hostlist_expr = sys.argv[1]
    logger.info(f"Slurmctld invoked RebootProgram {hostlist_expr}")
    for node in expand_nodes(hostlist_expr):
        server_uuid = get_openstack_server_id(node)
        if not server_uuid:
            continue # can just try next one (but really should now exit > 0 even if others succeed)
        reason = get_reboot_reason(node)
        if not reason.startswith("rebuild"):
            reboot_openstack_server(server_uuid) # TODO: support selecting soft or hard reboot via reason?
        else:
            rebuild_openstack_server(server_uuid, reason)

if __name__ == "__main__":
    try:
        rebuild_or_reboot()
    except:
        logger.exception('Exception in main:')
        raise