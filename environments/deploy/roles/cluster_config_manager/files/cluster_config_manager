#!/bin/env python3

import ldap
import argparse
import time
import os
import subprocess
import re
import yaml


class LDAPSyncToPasswd:
    """
    Sync UNIX group,passwd,shadow with LDAP
    """
    def __init__(self, username, password, ldapserver, filtergroup, verifiedgroups=None, uid_min=0, uid_max=1000000, gid_min=0, gid_max=1000000, template_files={"passwd": ["compute/passwd", "mds/passwd"], "group": ["compute/group", "mds/group"], "shadow": ["compute/shadow", "mds/shadow"]}, debug=False):  # noqa
        self.verifiedgroups = verifiedgroups
        self.ld = ldap.initialize(ldapserver)
        self.template_users = {}
        self.template_groups = {}
        self.basepath = os.path.dirname(os.path.realpath(__file__))
        self.template_basepath = "{}/templates".format(self.basepath)
        self.output_basepath = "{}/output".format(self.basepath)
        self.commit_basepath = "{}/commit_etc".format(self.basepath)
        self.history_filepath = "{}/cluster_config_manager_history.yaml".format(self.basepath)
        self.users = {}
        self.groups = {}
        self.debug = debug
        self.primary_groups = {}
        self.gid_min = gid_min
        self.gid_max = gid_max
        self.uid_min = uid_min
        self.uid_max = uid_max
        self.template_files = template_files
        self.file_lines = {}  # dicts with lists in it
        self.filtergroup = filtergroup
        self.history = {}
        self.current_history = {}

        # Load History file
        self.load_history_file()

        # Create template, output, and commit_etc directories
        if not os.path.isdir(self.template_basepath):
            os.mkdir(self.template_basepath)
        if not os.path.isdir(self.output_basepath):
            os.mkdir(self.output_basepath)
        if not os.path.isdir(self.commit_basepath):
            os.mkdir(self.commit_basepath)

        # Authenticate with LDAP Server
        self.ld.simple_bind_s(username, password)

        # Populate Groups
        result_set = self.ldap_query('cn=groups,cn=accounts,dc=hpc,dc=nrel,dc=gov',  # noqa
                                     ldap.SCOPE_SUBTREE,
                                     'objectClass=posixgroup',
                                     ("cn", "gidNumber"))
        self.parse_groups_query(result_set)

        # Populate Users
        result_set = self.ldap_query('cn=users,cn=accounts,dc=hpc, dc=nrel, dc=gov',  # noqa
                                     ldap.SCOPE_SUBTREE,
                                     "memberOf=cn={},cn=groups,cn=accounts,dc=hpc,dc=nrel,dc=gov".format(self.filtergroup),
                                     ("uid", "uidNumber", "gidNumber", "cn", "loginShell", "homeDirectory", "memberOf"))

        # Query each user for the uid/group information
        self.parse_user_query(result_set)

    def test(self):
        for user in self.users:
            if "uid" in self.users[user]:
                print(self.users[user]["uid"])

    def load_history_file(self):
        """ Load configuration file and history of file changes """
        if os.path.isfile(self.history_filepath):
            with open(self.history_filepath, "r") as f:
                try:
                    self.history = yaml.load(f)
                except yaml.YAMLError as error:
                    print(error)
                    print("Failed to load file {}".format())
                    exit(1)
            self.current_history["linecount"] = {}
            self.current_history["linechange_threshold_inc"] = self.history["linechange_threshold_inc"]
            self.current_history["linechange_threshold_sub"] = self.history["linechange_threshold_sub"]
            self.current_history["min_linecount"] = self.history["min_linecount"]
        else:
            # Setup defaults if no history
            self.current_history["linecount"] = {}
            self.current_history["linechange_threshold_inc"] = 200
            self.current_history["linechange_threshold_sub"] = 30
            self.current_history["min_linecount"] = 10
            self.history["linecount"] = {}
            self.history["linechange_threshold_inc"] = 200
            self.history["linechange_threshold_sub"] = 30
            self.history["min_linecount"] = 10

    def save_history_file(self):
        """ Save configuration file and history of file changes """
        with open(self.history_filepath, "w") as f:
            try:
                yaml.dump(self.current_history, f, default_flow_style=False)
            except yaml.YAMLError as error:
                print(error)
                print("Failed to save file {}".format())
                exit(1)

    def __valid_passwd_line(self, line):
        return re.match('^[.a-zA-Z0-9_-]{1,64}:x:[0-9]+:[0-9]+:[^\0:]*:[^\0:]+:[^\0:]+$', line)

    def __valid_shadow_line(self, line):
        return re.match('^([.a-zA-Z0-9_-]{1,64}):[^:]+:(-?[0-9]+):[0-9]*:([0-9]*):[0-9]*:[^\0:]*:[^\0:]*:[^\0:]*$', line)

    def __valid_group_line(self, line):
        return re.match('^([a-zA-Z0-9\._-]{1,64}):[x*!]:[0-9]+:([a-zA-Z0-9\._,-]*)$', line)

    def __is_valid_groupid(self, group):
        """
        return true if the gid is within a valid range
        """
        if group >= self.gid_min and group <= self.gid_max:
            return True
        else:
            return False

    def ldap_query(self, base, scope, filter, items):
        """
        Search LDAP
        """
        timeout = 0
        result_id = self.ld.search(base, scope, filter, items)
        result_set = []
        while 1:
            (result_type, result_data) = self.ld.result(result_id, timeout)
            if (result_data == []):
                break
            else:
                if result_type == ldap.RES_SEARCH_ENTRY:
                    result_set.append(result_data)
        return result_set


    def parse_user_query(self, result_set):
        """
        Query echo user CN to get user information
        """
        for i in range(len(result_set)):
            for entry in result_set[i]:
                user = {}
                users_attr = entry[1]

                # Defaults to no expiration in shadow file
                user['accountExpiresUnix'] = -1

                for attribute in ("uid", "uidNumber", "gidNumber", "cn", "loginShell", "homeDirectory", "memberOf"):
                    if attribute in users_attr:
                        val = users_attr[attribute]
                        """ single element lists should just return the value """
                        if len(val) <= 1:
                            val = val[0]
                        """ Convert integer type attrbutes to int """
                        if attribute == "uidNumber" or attribute == "gidNumber":
                            user[attribute] = int(val)
                        elif attribute == "cn":
                            #if val in self.verifiedgroups:
                            #    continue # do not include groups as users
                            user["displayName"] = val
                        elif attribute == "homeDirectory":
                            user["unixHomeDirectory"] = val
                        else:
                            user[attribute] = val
                else:
                    continue
            self.users[user["uid"]] = user

    def parse_groups_query(self, result_set):
        """
        Populate the user_hash and group_hash that will later be used to
        generate the passwd, shadow, and group file
        """
        for i in range(len(result_set)):
            # Iterate through each group entry returned by LDAP
            for entry in result_set[i]:
                group_cn = entry[0]
                group_attr = entry[1]
                """ Verify the group has the UNIX Attributes,
                  Also check if the group is a "verified group"
                """
                if "gidNumber" in group_attr and "cn" in group_attr:
                    # Collect Group Information
                    groupname = group_attr["cn"][0].decode("utf-8").strip()
                    gidNumber = int(group_attr["gidNumber"][0].decode("utf-8").strip())

                    if groupname is None:
                        print("cant find groupname %s" % groupname)
                        continue

                    # Validate group id range
                    if self.__is_valid_groupid(gidNumber):
                        # Create New Group entry in groups dict
                        self.groups[group_cn] = {}
                        self.groups[group_cn]['uid'] = groupname
                        self.groups[group_cn]['gidNumber'] = gidNumber
                        self.groups[group_cn]['member'] = []

                        # Populate array/list for each member in the group
                        try:
                            output = subprocess.check_output(['getent', 'group', groupname])
                            output_list = output.decode("utf-8").strip().split(":")
                            group_data = {"members": output_list[3].split(",")}

                            if "members" in group_data and group_data["members"][0] != "":
                                for username in group_data["members"]:
                                    # Append to the group members
                                    self.groups[group_cn]['member'].append(username)
                            else:
                                # print("Skipping empty group %s" % groupname)
                                pass
                        except subprocess.CalledProcessError:
                            print("Proc Failed to lookup group %s" % groupname)

    def check_validuser(self, user):
        """
        Verify a user should be included
        """
        message = ""
        rc = 0
        if 'uid' not in user or 'unixHomeDirectory' not in user:
            message += "#Error NoUnixAttributes;"
            rc |= 1
        else:
            if user['uidNumber'] < self.uid_min or user['uidNumber'] > self.uid_max:  # noqa
                message += "#Error %s uid out of range %s;" % (user['uid'], user['uidNumber'])  # noqa
                rc |= 4
            if 'gidNumber' in user:
                if user['gidNumber'] != user['uidNumber']:
                    message += "#Error %s gid(%s) does not = uid(%s)" % (user['uid'], user['gidNumber'], user['uidNumber'])  # noqa
                    rc |= 8
        if 'memberOf' in user:
            # Matches cn=ipausers,cn=groups,cn=accounts,dc=hpc,dc=nrel,dc=gov
            if b"cn=%s,cn=groups,cn=accounts,dc=hpc,dc=nrel,dc=gov" % self.filtergroup.encode() not in user['memberOf']:  # noqa
                if self.debug is True:
                    message += "#DEBUG: %s NotMemberOf the filter group %s" % (user['uid'], self.filtergroup)  # noqa
                rc |= 2
        return (message, rc)

    def check_validgroup(self, group):
        """
        Verify if a group should be included in output
        """
        message = ""
        rc = 0

        if ("gidNumber" not in group) or ("uid" not in group):
            if "uid" in group:
                message += "#Error %s NoGroupUnixAttributes" % group['uid']
                rc |= 1
            else:
                message += "#Error NoGroupUnixAttributes or uid"
                rc |= 4
            return (message, rc)

        if not self.__is_valid_groupid(group['gidNumber']):
            message += "#Error %s gid out of range;" % group['uid']
            rc |= 2
            return (message, rc)

        valid_group = False
        # Check verified group (non-primary groups)
        if group["uid"] in self.verifiedgroups:
            valid_group = True
        else:
            # Primary Groups Check
            # Find if the gid is that of a valid user
            for user in self.users:
                if group['gidNumber'] == self.users[user]['gidNumber']:
                    valid_group = True
                    break
        if valid_group is False:
            if self.debug is True:
                message += "#DEBUG: group %s is not from a valid user or a verified group, uid: %s, verifiedgroups: %s" % (group['uid'], group["uid"], self.verifiedgroups)  # noqa
            rc |= 8
            return (message, rc)

        return (message, rc)

    def generate_passwd_lines(self):
        """
        Parse user_hash and format for the unix /etc/passwd file
        Example /etc/passwd entry:
        ${uid}:x:${uidNumber}:${gidNumber}:${displayName}:${unixHomeDirectory}:${loginShell}  # noqa
        """
        for key in self.users:
            i = self.users[key]
            (message, rc) = self.check_validuser(i)
            if rc == 0:
                """ Sometimes the UIDs are returned as a LIST,
                 I do not understand why, maybe if multiple users have the
                 same UID. """
                if isinstance(i['uid'], list):
                    uid = i['uid'][0]
                line = "%s:x:%s:%s:%s:%s:%s" % (i['uid'].decode("utf-8"), i['uidNumber'], i['gidNumber'], i['displayName'].decode("utf-8"), i['unixHomeDirectory'].decode("utf-8"), i['loginShell'].decode("utf-8"))  # noqa
                for passwd_file in self.template_files["passwd"]:
                    self.file_lines[passwd_file].append(line)  # noqa
            else:
                if len(message) > 0:
                    print(message)

    def generate_shadow_lines(self):
        """
        Parse user_hash and format for the unix /etc/shadow file
        Example /etc/shadow entry:  ${uid}:x:${accountExpiresUnix}::::::
        """
        for key in self.users:
            i = self.users[key]
            (message, rc) = self.check_validuser(i)
            if rc == 0:
                line = "%s:x:%s::::::" % (i['uid'].decode("utf-8"), i['accountExpiresUnix'])
                for shadow_file in self.template_files["shadow"]:
                    self.file_lines[shadow_file].append(line)  # noqa
            else:
                if len(message) > 0:
                    print(message)

    def generate_group_lines(self):
        """
        Parse user_group and format for the unix /etc/group file
        Example /etc/groups entry:  ${uid}:*:${gidNumber}:${member}
        """
        def print_group_by_key(key, groups):
            i = groups[key]
            (message, rc) = self.check_validgroup(i)
            if rc == 0:
                if i["member"] is None:
                    membertext = ""
                else:
                    membertext = ",".join(i["member"])
                line = "%s:*:%s:%s" % (i['uid'], i['gidNumber'], membertext)
                for group_file in self.template_files["group"]:
                    self.file_lines[group_file].append(line)  # noqa
            else:
                if len(message) > 0:
                    print(message)

        for key in self.primary_groups:
            print_group_by_key(key, self.primary_groups)

        for key in self.groups:
            print_group_by_key(key, self.groups)

    def load_templates(self):
        """ Load template files """
        for template_type in self.template_files:
            for template in self.template_files[template_type]:
                with open("{}/{}".format(self.template_basepath, template), "r") as f:  # noqa
                    for line in f:
                        if template not in self.file_lines:
                            self.file_lines[template] = []
                        self.file_lines[template].append(line.strip())

    def generate_files(self):
        """ Write files from combined template and LDAP files """
        verified_lines = {}
        for template_type in self.template_files:
            for template in self.template_files[template_type]:
                verified_lines[template] = []
                # Write template file lines first
                for line in self.file_lines[template]:
                    if template_type == "group":
                        if not self.__valid_group_line(line):
                            print("Invalid group line: {}".format(line))
                            exit(1)
                    elif template_type == "passwd":
                        if not self.__valid_passwd_line(line):
                            print("Invalid passwd line: {}".format(line))
                            exit(1)
                    elif template_type == "shadow":
                        if not self.__valid_shadow_line(line):
                            print("Invalid shadow line: {}".format(line))
                            exit(1)

                    # Count lines
                    if template not in self.current_history["linecount"]:
                        self.current_history["linecount"][template] = 0
                    self.current_history["linecount"][template] += 1

                    verified_lines[template].append(line.strip())

            # Check if too many changes occured
            files_changed = False
            for template in self.template_files[template_type]:
                if template not in self.history["linecount"] or template not in self.current_history["linecount"]:
                    files_changed = True # First run, it changed
                else:
                    if self.history["linecount"][template] != self.current_history["linecount"][template]:
                        files_changed = True
                        if (self.history["linecount"][template]-self.current_history["linecount"][template]) > self.history["linechange_threshold_sub"]:  # noqa
                            print("{} file has linecount of {}, previously it has {} lines, too many changes between runs. You can clear the {} file history to force this to run. linechange_threshold_sub".format(template, self.current_history["linecount"][template], self.history["linecount"][template], self.history_filepath))
                            exit(1)
                        if (self.current_history["linecount"][template]-self.history["linecount"][template]) > self.history["linechange_threshold_inc"]:  # noqa
                            print("{} file has linecount of {}, previously it has {} lines, too many changes between runs. You can clear the {} file history to force this to run. linechange_threshold_inc".format(template, self.current_history["linecount"][template], self.history["linecount"][template], self.history_filepath))
                            exit(1)
                        if self.current_history["linecount"][template] < self.history["min_linecount"]:  # noqa
                            print("{} file has linecount of {} which does not meet the minimal linecount of {}. You can change the {} file configuration to lower the minimal linecount.".format(template, self.current_history["linecount"][template], self.history["min_linecount"], self.history_filepath))
                            exit(1)

                # Write the file if anything changed from the last run
                if files_changed == True:
                    # Write output file, holding place for writing the master file  # noqa
                    with open("{}/{}".format(self.output_basepath, template), "w") as f:  # noqa
                        for line in verified_lines[template]:
                            f.write("{}\n".format(line))

                    # Move to final copy destination, so its syncronous
                    os.rename("{}/{}".format(self.output_basepath, template), "{}/{}".format(self.commit_basepath, template))  # noqa


def main():
    """
    Begin Here
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("-u", "--ldap_username", help="LDAP username", type=str, required=True)  # noqa
    parser.add_argument("-p", "--ldap_password", help="LDAP password", type=str, required=True)  # noqa
    parser.add_argument("-l", "--ldap_server", help="LDAP server", type=str, required=True)  # noqa
    parser.add_argument("--uid_min", help="lowest valid UID", type=int, default=120000)  # noqa
    parser.add_argument("--uid_max", help="biggest valid UID", type=int, default=230000)  # noqa
    parser.add_argument("--gid_min", help="lowest valid GID", type=int, default=120000)  # noqa
    parser.add_argument("--gid_max", help="biggest valid GID", type=int, default=249999)  # noqa
    parser.add_argument("-g", "--filtergroup", help="group to show users from", type=str, required=True)  # noqa
    parser.add_argument("-f", "--groupfilterfile", help="file containing list of authorized groups or script to generate list of groups to filter by", type=str, default="")  # noqa
    args = parser.parse_args()

    """ Load the Group file,
        load each group as a key into the verifiedgroups dict """
    if len(args.groupfilterfile) >= 1 and os.path.isfile(args.groupfilterfile):  # noqa
        # Chck if groupfilterfile is executable, if it is, assume its a script to run  # noqa
        response = []
        verifiedgroups = []
        if not os.access(args.groupfilterfile, os.X_OK):
            # Open and read list of group file
            response = open(args.groupfilterfile, "r").readlines()
        else:
            # Run command and capture output for list of groups
            # Scripts should take options "--list" and print the output where each line is a group  # noqa
            cm_response = subprocess.Popen([args.groupfilterfile, "--list"], stdout=subprocess.PIPE)  # noqa
            (response, error_response) = cm_response.communicate()
            if int(cm_response.returncode) != 0:
                print("Failed to run %s, if this is intended to be a list of groups please chmod a-x %s" % (args.groupfilterfile, args.groupfilterfile))  # noqa
                exit(1)
            response = response.decode("utf-8").split("\n")

        # Parse results from command output or contents of the file
        for group in response:
            group = group.strip()
            if len(group) >= 1:
                verifiedgroups.append(group)
    else:
        # If no groups are verified, just print all the groups
        verifiedgroups = None

    # Query LDAP and gather passwd file object
    ldapsync = LDAPSyncToPasswd(args.ldap_username, args.ldap_password,
                                args.ldap_server, args.filtergroup,
                                verifiedgroups, args.uid_min, args.uid_max,
                                args.gid_min, args.gid_max, debug=False)

    # Generate files
    ldapsync.load_templates()
    ldapsync.generate_passwd_lines()
    ldapsync.generate_group_lines()
    ldapsync.generate_shadow_lines()
    ldapsync.generate_files()

    # Save history file and configs
    ldapsync.save_history_file()


if __name__ == "__main__":
    """ Entry Point """
    main()
